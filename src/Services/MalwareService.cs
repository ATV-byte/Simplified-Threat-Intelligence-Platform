using MongoDB.Bson;
using Simplified_Threat_Intelligence_Platform.Dtos;
using Simplified_Threat_Intelligence_Platform.Repositories;
using Simplified_Threat_Intelligence_Platform.Shared;
namespace Simplified_Threat_Intelligence_Platform.Services
{
    public class MalwareService
    {
        private readonly MalwareRepository _malware;
        private readonly IndicatorRepository _indicators;

        public MalwareService(MalwareRepository malware, IndicatorRepository indicators)
        {
            _malware = malware;
            _indicators = indicators;
        }

        public async Task<string> CreateAsync(MalwareCreateDto dto)
        {
            var duplicate = await FindDuplicateAsync(null, dto);
            if (duplicate is not null)
            {
                var id = duplicate["_id"].ToString();
                var name = duplicate["name"].AsString;
                throw new ConflictException($"Duplicate malware detected: ID={id}, Name={name}");
            }

            var indicatorIds = await _indicators.EnsureIndicatorsAsync(dto.Indicators);

            var doc = new BsonDocument
            {
                { "name", dto.Name },
                { "labels", new BsonArray(dto.Labels) },
                { "indicatorIds", new BsonArray(indicatorIds) },
                { "indicatorValues", new BsonArray(dto.Indicators.Select(i => i.Value)) },
                { "createdDate", dto.CreatedDate },
                { "updatedDate", dto.UpdatedDate }
            };

            return await _malware.InsertAsync(doc);
        }

        public async Task<List<MalwareViewDto>> GetRecentAsync()
        {
            var since = Epoch.DaysAgo(30);
            var docs = await _malware.GetRecentAsync(since);
            return docs.Select(ToView).ToList();
        }


        public async Task<List<MalwareViewDto>> SearchByValuesAsync(List<string> values)
        {
            var inds = await _indicators.FindByValuesAsync(values);
            if (inds.Count == 0) return new List<MalwareViewDto>();

            var ids = inds.Select(i => i["_id"].ToString()).ToList();
            var docs = await _malware.GetByIndicatorIdsAsync(ids);
            return docs.Select(ToView).ToList();
        }


        public async Task UpdateAsync(string id, MalwareUpdateDto dto)
        {
            
            var dup = await FindDuplicateAsync(
                currentIdToExclude: id,
                dto: new MalwareCreateDto
                {
                    Name = dto.Name,
                    Labels = dto.Labels,
                    Indicators = dto.Indicators,
                    CreatedDate = dto.CreatedDate,
                    UpdatedDate = dto.UpdatedDate
                }
            );

            if (dup is not null)
                throw new ConflictException($"Duplicate malware detected with ID={dup["_id"]} (name={dup["name"]})");


            var indicatorIds = await _indicators.EnsureIndicatorsAsync(dto.Indicators);

            var doc = new MongoDB.Bson.BsonDocument
            {
                { "_id", MongoDB.Bson.ObjectId.Parse(id) },
                { "name", dto.Name },
                { "labels", new MongoDB.Bson.BsonArray(dto.Labels) },
                { "indicatorIds", new MongoDB.Bson.BsonArray(indicatorIds) },
                { "indicatorValues", new MongoDB.Bson.BsonArray(dto.Indicators.Select(i => i.Value)) },
                { "createdDate", dto.CreatedDate },
                { "updatedDate", dto.UpdatedDate }
            };

            await _malware.ReplaceAsync(id, doc);
        }


        private static MalwareViewDto ToView(BsonDocument d) => new()
        {
            Id = d["_id"].ToString(),
            Name = d.GetValue("name", "").AsString,
            Labels = d.GetValue("labels", new BsonArray()).AsBsonArray.Select(x => x.AsString).ToList(),
            UpdatedDate = d.GetValue("updatedDate", 0).ToInt64()
        };

        private async Task<BsonDocument?> FindDuplicateAsync(string? currentIdToExclude, MalwareCreateDto dto)
        {
            static string Norm(string s) => (s ?? string.Empty).Trim().ToLowerInvariant();

            // --- Regula 1: nume identic ---
            var existingSameName = (await _malware.FindByNameAsync(dto.Name)).FirstOrDefault();
            if (existingSameName is not null &&
                existingSameName["_id"].ToString() != (currentIdToExclude ?? string.Empty))
                return existingSameName;

            // --- Regula 2: fereastră timp + subset/superset ---
            var newLabels = dto.Labels.Select(Norm).Where(x => x.Length > 0).ToHashSet();
            var newValues = dto.Indicators.Select(i => Norm(i.Value)).Where(x => x.Length > 0).ToHashSet();

            long newCreated = dto.CreatedDate;
            const int deltaSeconds = 120;

            var candidates = await _malware.FindByCreatedDateWindowAsync(newCreated, deltaSeconds);

            foreach (var cand in candidates)
            {
                var candId = cand.Contains("_id") ? cand["_id"].ToString() : "";
                if (!string.IsNullOrEmpty(currentIdToExclude) && candId == currentIdToExclude)
                    continue;

                var candLabels = cand.Contains("labels")
                    ? cand["labels"].AsBsonArray.Select(x => Norm(x.AsString)).Where(x => x.Length > 0).ToHashSet()
                    : new HashSet<string>();

                var candValues = cand.Contains("indicatorValues")
                    ? cand["indicatorValues"].AsBsonArray.Select(x => Norm(x.AsString)).Where(x => x.Length > 0).ToHashSet()
                    : new HashSet<string>();

                long candCreated = cand.Contains("createdDate")
                    ? cand["createdDate"].ToInt64()
                    : 0;

                bool timeOk = Math.Abs(candCreated - newCreated) <= deltaSeconds;
                bool labelsOk = newLabels.IsSubsetOf(candLabels) || candLabels.IsSubsetOf(newLabels);
                bool indicatorsOk = newValues.IsSubsetOf(candValues) || candValues.IsSubsetOf(newValues);

                if (timeOk && labelsOk && indicatorsOk)
                    return cand; // duplicat
            }

            return null; // nu e duplicat
        }


    }
}
